{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"../../README.md","title":"Home"},{"location":"caching/","text":"Caching Merging configuration on every request is not performant, particularly when using many configuration files. As such, zend-config-aggregator also provides the ability to enable a filesystem-based configuration cache. To enable the configuration cache, pass a cache file name as the second parameter to the ConfigAggregator constructor: use Zend\\ConfigAggregator\\ArrayProvider; use Zend\\ConfigAggregator\\ConfigAggregator; use Zend\\ConfigAggregator\\PhpFileProvider; $aggregator = new ConfigAggregator( [ new ArrayProvider([ConfigAggregator::ENABLE_CACHE => true]), new PhpFileProvider('*.global.php'), ], 'data/config-cache.php' ); When a cache file is specified, you will also need to add the config_cache_enabled key (which you can also specify via the ConfigAggregator::ENABLE_CACHE constant) somewhere within one of your configuration providers, and set it to boolean true . Using this approach, if you were to use the globbing pattern {{,*.}global,{,*.}local}.php (or similar) with the PhpFileProvider , you could drop a file named enable-cache.local.php into your production deployment with the following contents in order to enable configuration caching in production: <?php use Zend\\ConfigAggregator\\ConfigAggregator; return [ ConfigAggregator::ENABLE_CACHE => true, ]; When caching is enabled, the ConfigAggregator does not iterate config providers. Because of that it is very fast, but after it is enabled, you cannot make any changes to configuration without clearing the cache. Caching should be used only in a production environment , and your deployment process should clear the cache.","title":"Caching"},{"location":"caching/#caching","text":"Merging configuration on every request is not performant, particularly when using many configuration files. As such, zend-config-aggregator also provides the ability to enable a filesystem-based configuration cache. To enable the configuration cache, pass a cache file name as the second parameter to the ConfigAggregator constructor: use Zend\\ConfigAggregator\\ArrayProvider; use Zend\\ConfigAggregator\\ConfigAggregator; use Zend\\ConfigAggregator\\PhpFileProvider; $aggregator = new ConfigAggregator( [ new ArrayProvider([ConfigAggregator::ENABLE_CACHE => true]), new PhpFileProvider('*.global.php'), ], 'data/config-cache.php' ); When a cache file is specified, you will also need to add the config_cache_enabled key (which you can also specify via the ConfigAggregator::ENABLE_CACHE constant) somewhere within one of your configuration providers, and set it to boolean true . Using this approach, if you were to use the globbing pattern {{,*.}global,{,*.}local}.php (or similar) with the PhpFileProvider , you could drop a file named enable-cache.local.php into your production deployment with the following contents in order to enable configuration caching in production: <?php use Zend\\ConfigAggregator\\ConfigAggregator; return [ ConfigAggregator::ENABLE_CACHE => true, ]; When caching is enabled, the ConfigAggregator does not iterate config providers. Because of that it is very fast, but after it is enabled, you cannot make any changes to configuration without clearing the cache. Caching should be used only in a production environment , and your deployment process should clear the cache.","title":"Caching"},{"location":"config-post-processors/","text":"Post processors The ConfigAggregator can apply post processors to the merged configuration by aggregating \"config processors\" passed to its constructor. Each processor should be a PHP callable which consumes the merged configuration as its sole argument, and which then returns the processed configuration array. $providers = [ function () { return ['foo' => 'bar']; }, new PhpFileProvider('*.global.php'), ]; $processors = [ function (array $config) { return $config + ['post-processed' => true]; }, ]; $aggregator = new ConfigAggregator($providers, null, $processors); var_dump($aggregator->getMergedConfig()); Output from the example: array(2) { 'foo' => string(3) \"bar\" 'post-processed' => bool(true) } If the processor is a class name, the aggregator automatically instantiates it before invoking it; as such, any class name you use as a config provider must also define __invoke() , and that method must return an array and may consume the merged configuration as a parameter. Post processors can be used to mimic tools such as the Symfony configuration parameter system . As an example, you can specify a config processor which consumes the merged configuration and resolves templated parameters to other parameters within your configuration. Post processor examples Symfony ParameterBag Post Processor The following example resolves templated parameters to either other parameters within your configuration, or a static set of substitutions. Templated parameters have the format %<config_key>% ; . characters indicate an additional level of nesting. If you want to provide configuration parameters with % in the value, you must escape any occurences of % by using another % ; as examples, %%bar or %%foo%% . In the following example, we define a provider that returns a nested array of configuration. We then define additional parameters and pass them to a Symfony DI ParameterBag , which we develop a closure over. This closure checks for parameters in the passed configuration itself, and then attempts to resolve all configuration values based on the parameters in the ParameterBag . $provider = [ function () { return [ 'session' => [ 'cookie_domain' => '%cookie_domain%', ], 'tracking' => [ 'cookie_domain' => '%cookie_domain%', ], // Will be converted to %foo% after resolving 'config_parameter_with_percent' => '%%foo%%', ]; }, ]; $parameters = [ 'cookie_domain' => 'example.com', ]; $bag = new \\Symfony\\Component\\DependencyInjection\\ParameterBag\\ParameterBag($parameters); $resolver = function (array $config) use ($bag) { $parametersFromConfiguration = isset($config['parameters']) ? $config['parameters'] : []; $bag->add($parametersFromConfiguration); // Resolve parameters which probably base on parameters $bag->resolve(); // Replace all parameters within the configuration $resolved = $bag->resolveValue($config); $resolved['parameters'] = $bag->all(); return $bag->unescapeValue($resolved); }; $aggregator = new ConfigAggregator($provider, null, [ $resolver, ]); var_dump($aggregator->getMergedConfig()); The above would result in the following when complete: array(2) { 'session' => array(1) { 'cookie_domain' => string(11) \"example.com\" } 'tracking' => array(1) { 'cookie_domain' => string(11) \"example.com\" } 'config_parameter_with_percent' => string(7) \"%foo%\" } 'parameters' => array(1) { 'cookie_domain' => string(11) \"example.com\" } } There is an extension for this feature available via the package zendframework/zend-config-aggregator-parameters : $ composer require zendframework/zend-config-aggregator-parameters","title":"Post Processors"},{"location":"config-post-processors/#post-processors","text":"The ConfigAggregator can apply post processors to the merged configuration by aggregating \"config processors\" passed to its constructor. Each processor should be a PHP callable which consumes the merged configuration as its sole argument, and which then returns the processed configuration array. $providers = [ function () { return ['foo' => 'bar']; }, new PhpFileProvider('*.global.php'), ]; $processors = [ function (array $config) { return $config + ['post-processed' => true]; }, ]; $aggregator = new ConfigAggregator($providers, null, $processors); var_dump($aggregator->getMergedConfig()); Output from the example: array(2) { 'foo' => string(3) \"bar\" 'post-processed' => bool(true) } If the processor is a class name, the aggregator automatically instantiates it before invoking it; as such, any class name you use as a config provider must also define __invoke() , and that method must return an array and may consume the merged configuration as a parameter. Post processors can be used to mimic tools such as the Symfony configuration parameter system . As an example, you can specify a config processor which consumes the merged configuration and resolves templated parameters to other parameters within your configuration.","title":"Post processors"},{"location":"config-post-processors/#post-processor-examples","text":"","title":"Post processor examples"},{"location":"config-post-processors/#symfony-parameterbag-post-processor","text":"The following example resolves templated parameters to either other parameters within your configuration, or a static set of substitutions. Templated parameters have the format %<config_key>% ; . characters indicate an additional level of nesting. If you want to provide configuration parameters with % in the value, you must escape any occurences of % by using another % ; as examples, %%bar or %%foo%% . In the following example, we define a provider that returns a nested array of configuration. We then define additional parameters and pass them to a Symfony DI ParameterBag , which we develop a closure over. This closure checks for parameters in the passed configuration itself, and then attempts to resolve all configuration values based on the parameters in the ParameterBag . $provider = [ function () { return [ 'session' => [ 'cookie_domain' => '%cookie_domain%', ], 'tracking' => [ 'cookie_domain' => '%cookie_domain%', ], // Will be converted to %foo% after resolving 'config_parameter_with_percent' => '%%foo%%', ]; }, ]; $parameters = [ 'cookie_domain' => 'example.com', ]; $bag = new \\Symfony\\Component\\DependencyInjection\\ParameterBag\\ParameterBag($parameters); $resolver = function (array $config) use ($bag) { $parametersFromConfiguration = isset($config['parameters']) ? $config['parameters'] : []; $bag->add($parametersFromConfiguration); // Resolve parameters which probably base on parameters $bag->resolve(); // Replace all parameters within the configuration $resolved = $bag->resolveValue($config); $resolved['parameters'] = $bag->all(); return $bag->unescapeValue($resolved); }; $aggregator = new ConfigAggregator($provider, null, [ $resolver, ]); var_dump($aggregator->getMergedConfig()); The above would result in the following when complete: array(2) { 'session' => array(1) { 'cookie_domain' => string(11) \"example.com\" } 'tracking' => array(1) { 'cookie_domain' => string(11) \"example.com\" } 'config_parameter_with_percent' => string(7) \"%foo%\" } 'parameters' => array(1) { 'cookie_domain' => string(11) \"example.com\" } } There is an extension for this feature available via the package zendframework/zend-config-aggregator-parameters : $ composer require zendframework/zend-config-aggregator-parameters","title":"Symfony ParameterBag Post Processor"},{"location":"config-providers/","text":"Config providers The ConfigAggregator works by aggregating \"config providers\" passed to its constructor. Each provider should be a callable, returning a configuration array (or a PHP generator) to be merged. $aggregator = new ConfigAggregator([ function () { return ['foo' => 'bar']; }, new PhpFileProvider('*.global.php'), ]); var_dump($aggregator->getMergedConfig()); If the provider is a class name, the aggregator automatically instantiates it before invoking it; as such, any class name you use as a config provider must also define __invoke() , and that method must return an array. This can be used to mimic the Zend Framework module system: you can specify a list of config providers from different packages, and aggregated configuration will be available to your application. As a library owner, you can distribute your own configuration providers that provide default values for use with your library. As an example: class ApplicationConfig { public function __invoke() { return ['foo' => 'bar']; } } $aggregator = new ConfigAggregator([ ApplicationConfig::class, new PhpFileProvider('*.global.php'), ]); var_dump($aggregator->getMergedConfig()); Output from both examples will be the same: array(4) { 'foo' => string(3) \"bar\" 'db' => array(1) { 'dsn' => string(9) \"mysql:...\" } 'cache_storage' => string(5) \"redis\" 'redis' => array(0) { } } Generators Config providers can be written as generators. This way, a single callable can provide multiple configurations: use Zend\\ConfigAggregator\\ConfigAggregator; use Zend\\Stdlib\\Glob; $aggregator = new ConfigAggregator([ function () { foreach (Glob::glob('data/*.global.php', Glob::GLOB_BRACE) as $file) { yield include $file; } }, ]); var_dump($aggregator->getMergedConfig()); The PhpFileProvider is implemented as a generator. Available config providers PhpFileProvider Loads configuration from PHP files returning arrays, such as this one: return [ 'db' => [ 'dsn' => 'mysql:...', ], ]; Wildcards are supported: use Zend\\ConfigAggregator\\ConfigAggregator; use Zend\\ConfigAggregator\\PhpFileProvider; $aggregator = new ConfigAggregator( [ new PhpFileProvider('config/*.global.php'), ] ); The example above will merge all matching files from the config/ directory. If you have files such as app.global.php or database.global.php in that directory, they will be loaded using this above lines of code. The provider also supports globbing . Globbing defaults to PHP's glob() function. However, if Zend\\Stdlib\\Glob is available, it will use that to allow for cross-platform glob patterns, including brace notation: 'config/autoload/{{,*.}global,{,*.}local}.php' . Install zendframework/zend-stdlib to utilize this feature. ZendConfigProvider Sometimes using plain PHP files may be not enough; you may want to build your configuration from multiple files of different formats, such as INI, JSON, YAML, or XML. zend-config-aggregator allows you to do so via its ZendConfigProvider . This feature requires first installing zend-config: $ composer require zendframework/zend-config Once installed, you may use as many ZendConfigProvider instances as you need: use Zend\\ConfigAggregator\\ConfigAggregator; use Zend\\ConfigAggregator\\ZendConfigProvider; $aggregator = new ConfigAggregator( [ new ZendConfigProvider('*.global.json'), new ZendConfigProvider('database.local.ini'), ] ); These could even be combined into a single glob statement: $aggregator = new ConfigAggregator( [ new ZendConfigProvider('*.global.json,database.local.ini'), ] ); ZendConfigProvider accepts wildcards and globs, and autodetects the config type based on file extension. Some config readers (in particular, YAML) may need additional dependencies; please refer to the zend-config manual for more details. ZendModuleProvider To provide configuration using Module classes created for zendframework/zend-mvc applications, you can use the ZendModuleProvider , via the package zendframework/zend-config-aggregator-modulemanager . This provider introspects the module class for its Module::getConfig() method as well as its Module::getServiceConfig() method (declared via the ServiceProviderInterface ). To use the extension, first install its package: $ composer require zendframework/zend-config-aggregator-modulemanager Once installed, you may use as many ZendModuleProvider instances as you need: use Zend\\ConfigAggregator\\ConfigAggregator; use Zend\\ConfigAggregatorModuleManager\\ZendModuleProvider; use ACME; $aggregator = new ConfigAggregator([ new ZendModuleProvider(new ACME\\Module()), ]); ZendModuleProvider accepts any object which represents a zend-mvc module. For more details, please refer to the zend-config-aggregator-modulemanager manual .","title":"Config Providers"},{"location":"config-providers/#config-providers","text":"The ConfigAggregator works by aggregating \"config providers\" passed to its constructor. Each provider should be a callable, returning a configuration array (or a PHP generator) to be merged. $aggregator = new ConfigAggregator([ function () { return ['foo' => 'bar']; }, new PhpFileProvider('*.global.php'), ]); var_dump($aggregator->getMergedConfig()); If the provider is a class name, the aggregator automatically instantiates it before invoking it; as such, any class name you use as a config provider must also define __invoke() , and that method must return an array. This can be used to mimic the Zend Framework module system: you can specify a list of config providers from different packages, and aggregated configuration will be available to your application. As a library owner, you can distribute your own configuration providers that provide default values for use with your library. As an example: class ApplicationConfig { public function __invoke() { return ['foo' => 'bar']; } } $aggregator = new ConfigAggregator([ ApplicationConfig::class, new PhpFileProvider('*.global.php'), ]); var_dump($aggregator->getMergedConfig()); Output from both examples will be the same: array(4) { 'foo' => string(3) \"bar\" 'db' => array(1) { 'dsn' => string(9) \"mysql:...\" } 'cache_storage' => string(5) \"redis\" 'redis' => array(0) { } }","title":"Config providers"},{"location":"config-providers/#generators","text":"Config providers can be written as generators. This way, a single callable can provide multiple configurations: use Zend\\ConfigAggregator\\ConfigAggregator; use Zend\\Stdlib\\Glob; $aggregator = new ConfigAggregator([ function () { foreach (Glob::glob('data/*.global.php', Glob::GLOB_BRACE) as $file) { yield include $file; } }, ]); var_dump($aggregator->getMergedConfig()); The PhpFileProvider is implemented as a generator.","title":"Generators"},{"location":"config-providers/#available-config-providers","text":"","title":"Available config providers"},{"location":"config-providers/#phpfileprovider","text":"Loads configuration from PHP files returning arrays, such as this one: return [ 'db' => [ 'dsn' => 'mysql:...', ], ]; Wildcards are supported: use Zend\\ConfigAggregator\\ConfigAggregator; use Zend\\ConfigAggregator\\PhpFileProvider; $aggregator = new ConfigAggregator( [ new PhpFileProvider('config/*.global.php'), ] ); The example above will merge all matching files from the config/ directory. If you have files such as app.global.php or database.global.php in that directory, they will be loaded using this above lines of code. The provider also supports globbing . Globbing defaults to PHP's glob() function. However, if Zend\\Stdlib\\Glob is available, it will use that to allow for cross-platform glob patterns, including brace notation: 'config/autoload/{{,*.}global,{,*.}local}.php' . Install zendframework/zend-stdlib to utilize this feature.","title":"PhpFileProvider"},{"location":"config-providers/#zendconfigprovider","text":"Sometimes using plain PHP files may be not enough; you may want to build your configuration from multiple files of different formats, such as INI, JSON, YAML, or XML. zend-config-aggregator allows you to do so via its ZendConfigProvider . This feature requires first installing zend-config: $ composer require zendframework/zend-config Once installed, you may use as many ZendConfigProvider instances as you need: use Zend\\ConfigAggregator\\ConfigAggregator; use Zend\\ConfigAggregator\\ZendConfigProvider; $aggregator = new ConfigAggregator( [ new ZendConfigProvider('*.global.json'), new ZendConfigProvider('database.local.ini'), ] ); These could even be combined into a single glob statement: $aggregator = new ConfigAggregator( [ new ZendConfigProvider('*.global.json,database.local.ini'), ] ); ZendConfigProvider accepts wildcards and globs, and autodetects the config type based on file extension. Some config readers (in particular, YAML) may need additional dependencies; please refer to the zend-config manual for more details.","title":"ZendConfigProvider"},{"location":"config-providers/#zendmoduleprovider","text":"To provide configuration using Module classes created for zendframework/zend-mvc applications, you can use the ZendModuleProvider , via the package zendframework/zend-config-aggregator-modulemanager . This provider introspects the module class for its Module::getConfig() method as well as its Module::getServiceConfig() method (declared via the ServiceProviderInterface ). To use the extension, first install its package: $ composer require zendframework/zend-config-aggregator-modulemanager Once installed, you may use as many ZendModuleProvider instances as you need: use Zend\\ConfigAggregator\\ConfigAggregator; use Zend\\ConfigAggregatorModuleManager\\ZendModuleProvider; use ACME; $aggregator = new ConfigAggregator([ new ZendModuleProvider(new ACME\\Module()), ]); ZendModuleProvider accepts any object which represents a zend-mvc module. For more details, please refer to the zend-config-aggregator-modulemanager manual .","title":"ZendModuleProvider"},{"location":"intro/","text":"Introduction zend-config-aggregator is a lightweight library for managing application configuration. It was designed to be flexible in dev environments and fast in production. It supports loading and merging configuration from multiple sources: PHP files, arrays, or INI/YAML/XML files (using zend-config ) It also provides the ability to post process the merged configuration to apply e.g. parameter handling like symfony/dependency-injection Basic usage The standalone ConfigAggregator can be used to merge PHP-based configuration files: use Zend\\ConfigAggregator\\ConfigAggregator; use Zend\\ConfigAggregator\\PhpFileProvider; $aggregator = new ConfigAggregator([ new PhpFileProvider('*.global.php'), ]); var_dump($aggregator->getMergedConfig()); Using this provider, each file should return a PHP array: // db.global.php return [ 'db' => [ 'dsn' => 'mysql:...', ], ]; // cache.global.php return [ 'cache_storage' => 'redis', 'redis' => [ ... ], ]; Result: array(3) { 'db' => array(1) { 'dsn' => string(9) \"mysql:...\" } 'cache_storage' => string(5) \"redis\" 'redis' => array(0) { ... } } Configuration is merged in the same order as it is passed, with later entries having precedence. Together with zend-config , zend-config-aggregator can be also used to load configuration in different formats, including YAML, JSON, XML, or INI: use Zend\\ConfigAggregator\\ConfigAggregator; use Zend\\ConfigAggregator\\ZendConfigProvider; $aggregator = new ConfigAggregator([ new ZendConfigProvider('config/*.{json,yaml,php}'), ]); You can also supply post processors for configuration. These are PHP callables that accept the merged configuration as an argument, do something with it, and return configuration on completion. This could be used, for example, to allow templating parameters that are used in multiple locations and resolving them to a single value later.","title":"Introduction"},{"location":"intro/#introduction","text":"zend-config-aggregator is a lightweight library for managing application configuration. It was designed to be flexible in dev environments and fast in production. It supports loading and merging configuration from multiple sources: PHP files, arrays, or INI/YAML/XML files (using zend-config ) It also provides the ability to post process the merged configuration to apply e.g. parameter handling like symfony/dependency-injection","title":"Introduction"},{"location":"intro/#basic-usage","text":"The standalone ConfigAggregator can be used to merge PHP-based configuration files: use Zend\\ConfigAggregator\\ConfigAggregator; use Zend\\ConfigAggregator\\PhpFileProvider; $aggregator = new ConfigAggregator([ new PhpFileProvider('*.global.php'), ]); var_dump($aggregator->getMergedConfig()); Using this provider, each file should return a PHP array: // db.global.php return [ 'db' => [ 'dsn' => 'mysql:...', ], ]; // cache.global.php return [ 'cache_storage' => 'redis', 'redis' => [ ... ], ]; Result: array(3) { 'db' => array(1) { 'dsn' => string(9) \"mysql:...\" } 'cache_storage' => string(5) \"redis\" 'redis' => array(0) { ... } } Configuration is merged in the same order as it is passed, with later entries having precedence. Together with zend-config , zend-config-aggregator can be also used to load configuration in different formats, including YAML, JSON, XML, or INI: use Zend\\ConfigAggregator\\ConfigAggregator; use Zend\\ConfigAggregator\\ZendConfigProvider; $aggregator = new ConfigAggregator([ new ZendConfigProvider('config/*.{json,yaml,php}'), ]); You can also supply post processors for configuration. These are PHP callables that accept the merged configuration as an argument, do something with it, and return configuration on completion. This could be used, for example, to allow templating parameters that are used in multiple locations and resolving them to a single value later.","title":"Basic usage"}]}